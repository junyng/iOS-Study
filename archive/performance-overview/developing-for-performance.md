# Developing for Performance

성능은 소프트웨어 설계가 심각한 문제가 될 때까지 간과되는 측면이다. 개발 주기가 끝날 때까지 대기하여 성능 조정을 수행한다면, 중요한 개선을 달성하기에는 너무 늦을 수 있다. 성능은 설계 단계 초기에 포함시키고 개발 주기 전반에 걸쳐 지속적으로 개선해야 할 사항이다.

물론 성능을 설계하기 위해서는 성능이 무엇인지 이해하는 데 도움이 된다. 이 장의 섹션은 성능에 영향을 미치는 요소, OS X와 iOS에서 그러한 요소들이 어떻게 스스로 나타나는지, 그리고 그러한 요소들의 모니터링에 어떻게 접근할 수 있는지에 대한 배경 정보를 제공한다.

### What Is Performance?

"성능"이라는 용어는 다른 사람에 다른 것을 의미할 수도 있다. 그러므로 애플리케이션의 성능을 향상시키기 위한 탐구를 시작하기 전에, 지금 이 용어가 무엇을 의미하는지 생각해 볼 좋은 시간이다.

많은 사람들이 성능과 속도를 동일시한다. 실제로 프로그램이 1초만에 복잡한 연산을 수행한다면 프로그램 성능이 좋다고 생각할 수 있다. 그러나 속도 자체는 잘못된 측정일 수 있다. 복잡한 소프트웨어 시스템에서 작업 속도는 고정된 값이 아니다. 다른 조건에서 동일한 작업을 여러 번 수행할 경우 해당 작업을 완료하는 데 걸리는 시간이 크게 달라질 수 있다. 프로그램은 로컬 시스템에서 자원을 공유하는 많은 프로세스 중 하나에 불과하며, 이러한 자원의 사용\(또는 남용\)은 다른 모든 프로세스에 영향을 미치기 때문이다.

다음 절에서는 효율적인 자원 사용과 지각된 성능이라는 두 가지 개념으로 성능을 설명한다. 이 두 개념 모두 애플리케이션을 설계하고 구현하는 방법에 중요한 영향을 미치며, 이 두 개념을 사용하는 방법을 이해하면 전반적인 성능이 향상될 수 있다.

#### The Efficient Use of Resources

컴퓨터는 모든 실행 중인 프로세스 중에서 제한된 수의 리소스를 공유한다. 가장 저수준에서 이러한 자원은 다음과 같은 범주로 나뉜다:

* CPU 시간
* 메모리 공간
* 대용량 저장 공간

당신의 모든 데이터는 메모리나 어떤 종류의 대용량 저장 장치에 저장되며 CPU에 의해 작동되어야 한다. 효율적인 애플리케이션은 이러한 모든 자원을 신중하게 사용한다. 다음 절에서는 각 리소스 유형과 해당 리소스 유형이 프로그램에 미치는 영향에 대해 자세히 설명한다.

**CPU Time**

CPU 시간은 시스템에 의해 전달되므로 현재 시간을 최대한 활용해야 한다. OS X와 iOS 모두 대칭형 다중 처리를 구현하기 때문에 시스템의 각 쓰레드에 실행할 타임 슬라이스\(최대 10 밀리초\)가 할당된다. 그 시간의 마지막\(또는 많은 경우 이전\)에 시스템은 CPU를 다시 제어하여 다른 쓰레드에 제공한다.

많은 활성 쓰레드가 있는 일반적인 시스템에서 모든 쓰레드가 전체 시간 할당을 사용한다면 성능은 형편없을 것이다. 이는 애플리케이션 생성을 위한 가장 중요한 목표 중 하나로 이어진다:

_목표: 프로그램과 무관한 경우, CPU 시간을 소비하지 않아야 한다._

목표를 달성하는 가장 좋은 방법은 이벤트 기반 모델을 사용하는 것이다. Cocoa와 iOS에서 발견되는 것과 같은 현대의 이벤트 처리 시스템을 사용하는 것은 해야 할 일이 있을 때만 프로그램의 쓰레드가 실행된다는 것을 의미한다.

애플리케이션이 작업해야 할 일이 있을 경우 CPU 시간을 최대한 효과적으로 사용해야 한다. 이는 처리할 것으로 예상되는 데이터 양에 적합한 알고리즘을 선택하는 것을 의미한다. 또한 사용 가능한 벡터 단위 \(OS X의 AltiVec 또는 SSE\) 또는 그래픽 프로세서와 같은 다른 시스템 자원을 사용하여 전문 작**업**을 수행하여 다음 목표를 달성하는 것을 의미한다.

_목표: 가능한 경우 CPU에서 작업을 이동하라._

CPU 시간을 효과적으로 사용하는 방법에 대한 기본 정보는 [Fundamental Optimization Tips](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCIFICC)을 참조하라. 그리기 작업 속도 개선과 관련된 자세한 내용은 [Drawing Code](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCGCFAB)를 참조하라.

**Memory Space**

현대 컴퓨팅 하드웨어에 대한 메모리는 일반적으로 점진적으로 느린 \(그러나 더 큰\) 유형의 메모리로 구성된다. CPU에서 가장 빠른 메모리는 CPU 자체 레지스터이다. 다음으로 빠른 것은 L1 캐시이고, 사용 가능한 경우 L2 및 L3 캐시가 뒤따른다. 다음으로 빠른 메모리는 메인 메모리이다. 모든 메모리 중 가장 느린 메모리는 디스크에 있으며 사용하기 전에 페이지로 입력해야하는 OS X의 가상 메모리 페이지로 구성된다.

이상적인 세계에서는 모든 애플리케이션 시스템에서 가장 빠른 캐시 메모리에 맞을 만큼 작을 것이다. 불행히도, 대부분의 애플리케이션 코드와 데이터는 메인 메모리 또는 디스크에 있다. 따라서 애플리케이션의 코드와 데이터는 이러한 느린 미디어에서 소비되는 시간을 최소화하는 방식으로 구성되어 다음과 같은 목표로 이어지는 것이 중요하다:

_Goal:프로그램의 메모리 설치 공간을 줄여라._

프로그램의 메모리 크기를 줄이면 성능이 크게 향상될 수 있다. 작은 메모리 설치 공간은 보통 두 가지 장점을 가진다. 첫째, 당신의 프로그램이 작을수록, 그것은 더 적은 메모리 페이지를 차지한다. 메모리 페이지 수가 적다는 것은 일반적으로 페이징이 적다는 것을 의미한다. 둘째, 코드는 일반적으로 더 많이 최적화되고 더 잘 조직된 결과로 더 작다. 따라서 주어진 작업을 수행하는 데 필요한 가이드가 적고 해당 작업에 대한 모든 코드가 동일한 메모리 페이지에 수집된다.

애플리케이션의 메모리 사용 공간을 줄이는 것 외에도 애플리케이션에서 쓰기 가능한 메모리 페이지의 사용 공간도 줄여라. 쓰기 가능한 메모리 페이지는 애플리케이션에 대해 전역 또는 할당된 데이터를 저장한다. OS X에서는 이러한 페이지를 필요한 경우 디스크에 쓸 수 있지만, 그렇게 하는 것은 느리다. iOS에서, 이 페이지의 내용은 애플리케이션이 해당 페이지에 있던 데이터를 재생성하도록 요구할 수 있다. 두 경우 모두 메모리를 확보하려는 시스템의 노력은 시간이 소요되며, 이는 애플리케이션 코드를 실행하는 데 더 나은 시간이 될 수 있다.

프로그램의 초기 메모리를 줄이는 방법에 대한 기본 정보는 [Application Footprint](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCJHDJH)를 참조하라. 메모리를 보다 효율적으로 사용하는 것과 관련된 팁은 [Memory Allocation Code](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCFHEGA)를 참조하라.

**Mass Storage Space**

모든 컴퓨터의 파일 시스템 성능은 거의 모든 것이 파일 어딘가에 있기 때문에 중요하다. 애플리케이션, 데이터, 운영 체제 자체도 모두 시스템의 다른 부분에 비해 엄청나게 느린 장치에서 메모리로 로드되어야 하는 파일에 상주한다. 파일 시스템은 로컬 또는 네트워크 기반이든 성능에 가장 큰 병목현상 중 하나이다. 이것은 또 다른 목표로 이어진다:

목표: 불필요한 파일 작업을 없애고 정보가 실제로 필요할 때까지 다른 작업을 지연시켜라.

파일 작업을 제거하거나 지연시킴으로써 이러한 병목 현을 제거하는 것은 애플리케이션의 전반적인 성능을 향상시키는 데 중요하다. 수천만 개의 CPU 사이클이 파일로부터 데이터를 요청하는 시간과 프로그램이 해당 데이터를 실제로 보는 시간 사이에 경과할 수 있다. 프로그램이 많은 수의 파일에 접근하는 경우, 요청된 모든 데이터를 수신하기 전에 수 초 동안 대기할 수 있다.

기억해야 할 또 다른 중요한 점은 애플리케이션과 애플리케이션이 생성하는 모든 파일이 로컬 하드 디스크 대신 네트워크에 있을 수 있다는 것이다. 특히 OS X는 네트워크를 가능한 한 눈에 보이지 않게 하므로, 파일의 지역성에 대해서는 절대로 가정해서는 안 된다.

프로그램의 파일 기반 성능을 향상시키는 방법에 대한 기본 정보는 [File Access Code](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCEGGIH)를 참조하라.

#### The Perception of Speed

최적의 성능을 위해 애플리케이션 코드를 조정하더라도 애플리케이션이 사용자에게 느리게 나타날 수 있다. 문제는 피할 수 없다: 할 일이 많으면 CPU 시간과 자원이 있어야 그 일을 할 수 있다. 애플리케이션의 속도의 외관을 부여하기 위해 당신이 할 수 있는 것들이 있고, 그것은 다음의 목표를 이끈다:

_목표: 프로그램이 사용자에게 응답하도록 한다._

반응성은 보통 원시 속도보다 사용자들에게 더 중요한 요소이다. 프로그램이 명령에 적시에 반응하는 한, 사용자는 종종 어떤 작업을 수행하는 데 시간이 더 오래 걸린다는 사실을 기꺼이 받아들인다. 속도 인식은 프로그램이 백그라운드에서 데이터를 처리하는 동안 사용자가 계속 작동하도록 함으로써 달성된다. 애플리케이션에서 수행되는 동시 작업 수를 개선하는 것은 사용자에게 응답할 수 있는 좋은 방법이다. 동시성은 일반적으로 Grand Central Dispatch 또는 쓰레드를 사용하여 구현된다. 애플리케이션의 메인 쓰레드가 사용자에게 응답하는 동안, 디스패치 큐 또는 백그라운드 쓰레드는 계산을 수행하거나 다른 시간 소모적인 작업을 처리한다.

애플리케이션을 빠르게 표시하는 또 다른 일반적인 방법은 시작시간을 단축하는 것이다. 시작하는 데 1~2초 이상 걸리는 애플리케이션은 아마도 너무 많은 작업을 하고 있을 것이다. 그 시간 동안 사용자에게 반응이 없을 뿐만 아니라 당장 필요하지 않거나 전혀 사용하지 않을 수 있는 자원을 로딩하고 있을 수 있어 낭비가 심하다. 시작 시간을 단축하는 방법에 대한 자세한 내용은 [Launch Time Initialization Code](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BBCCHDAF)를 참조하라. 프로그램의 인식된 성능 향상에 대한 자세한 내용은 [Take Advantage of Perceived Performance](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/BasicTips/BasicTips.html#//apple_ref/doc/uid/TP40001410-CH204-BCIFDFAA)를 참조하라.

### Tracking Performance

높은 성능을 보장하는 유일한 방법은 제품 설계에 성능 목표를 포함시키고 개발 프로세스 전체에 걸쳐 이러한 목표와 비교하여 제품을 측정하는 것이다. 코드가 기록되면 프로그램의 전체 성능에 미치는 영향을 아는 것이 중요하다. 성능 문제를 조기에 발견하면 더 늦기 전에 고칠 수 있는 좋은 기회가 생긴다.

특정 목표를 달성하는지 초과하는지 확인하는 방법은 메트릭을 수집하는 것이다. 애플은 프로그램의 성능을 모니터링하고 분석하기 위한 몇 가지 도구를 제공한다. 또한 데이터 수집 프로세스를 자동화하는 데 도움이 는 측정 도구를 코드에 직접 구축할 수 있다. 어떤 접근 방식을 선택하든, 당신은 그 도구들을 정기적으로 연습하고 결과를 분석해야 한다.

#### Establish Your Baseline Metrics

먼저 측정할 기준 메트릭 셋을 결정해야 한다. 사용자에게 가장 중요하다고 생각하는 작업을 선택하고 이러한 작업을 수행하기 위한 일련의 제약 조건을 식별하라. 예를 들어, 애플리케이션이 초기 윈도우를 1초 이내에 로드하고 표시하기를 원하거나, 주어진 목표 범위 내에서 전체 메모리 사용량을 유지하려고 할 수도 있다.

측정하기 위해 선택하는 작업은 사용자의 요구를 반영해야 한다. 마케팅 부서는 사용자가 관련 있다고 생각하는 일련의 작업을 선택하는 데 도움을 줄 수 있어야 한다. 확립된 제품이 있는 경우 사용자와 대화하여 어떤 기능을 느리게 생각하는지 알아보고 계획된 업데이트의 일부로 이러한 기능의 성능 향상을 고려하라.

추적할 작업 목록이 있으면 각 작업의 성능 대상을 결정하라. 기존 제품의 경우, 단순히 이전 버전의 성능을 향상시키려 할 수 있다. 당신은 또한 경쟁 제품의 성능을 측정하고 그 성능을 충족시키거나 초과한 목표를 설정하려고 할 수도 있다. 만약 당신이 새로운 제품을 가지고 있다면, 당신은 합리적인 값을 찾기 위해 숫자로 실험을 해야 할지도 모른다. 또는 진보적인 기준 값을 설정하고 가능한 한 기준 값에 가깝게 접근하려고 할 수 있다.

다른 성능 측정과 마찬가지로 일관성도 중요하다. 기준 메트릭을 설정하는 프로세스에는 이러한 메트릭을 수집하는 시스템에 대한 정보가 포함되어야 한다. 시스템의 하드웨어 및 소프트웨어 구성을 자세히 기록하고 항상 동일한 구성에 대해 테스트를 실행하라. 기준선을 설정하는 데 가장 느린 하드웨어 구성을 사용해 보라. 빠른 컴퓨터의 측정은 소프트웨어가 잘 작동한다고 믿게 할 수 있지만, 많은 사용자들은 더 느린 프로세서와 더 적은 메모리로 컴퓨터를 실행할 것이다.

#### Measure Early, Measure Often

성능 데이터는 한 번 수집할 수 있는 것이 아니며 프로그램의 모든 성능 병목 현상을 찾기를 희망한다. 프로그램 성능 기록을 유지하면 문제를 찾기가 더 쉽다. 기록을 유지 관리하면 애플리케이션의 성능이 향상되고 있는지 여부를 쉽게 확인할 수 있다. 감소하고 있는 경우 제품이 배송되기 전에 문제를 해결하기 위한 조치를 취할 수 있다.

정기적으로 성능을 측정하는 또 다른 이유는 이러한 결과를 코드 체크인과 연관시킬 수 있기 때문이다. 특정 마일스톤의 성능이 저하되는 경우, 해당 기간 동안 체크인된 코드를 검토하고 그 이유를 찾아라. 마찬가지로 성능이 향상되면 최신 코드 체크인을 좋은 프로그래밍 관행의 모델로 사용하고 팀에게 유사한 기술을 사용하도록 권장할 수 있다.

부분 기능 프로그램이 있는 즉시 성능 측정을 시작해야 한다. 새 기능이 추가되면 해당 기능에 대한 측정을 추가할 수 있다. 일련의 자동화된 진단 루틴을 프로그램에 직접 통합하면 팀원들이 결과를 즉시 확인할 수 있다. 이 정보를 쉽게 사용할 수 있게 되면 코드를 체크인하기 전에 성능 문제를 쉽게 해결할 수 있다.

#### Analyze Your Results

데이터 수집은 성능 병목 현상을 식별하는 데 있어 가장 중요한 단계이다. 하지만 일단 데이터가 확보되면 문제를 찾기 위해 데이터를 사용하는 것도 중요하다. 성능 데이터를 분석하는 것은 출력을 보고 문제를 바로 보는 것만큼 간단하지 않다. 운이 좋아서 문제를 빨리 볼 수도 있지만, 어떤 문제들은 더 미묘하고 더 세심한 분석이 필요하다.

결과를 분석하는 데 도움이 되는 한 가지 방법은 결과를 그래픽으로 표시하는 것이다. 성능 데이터를 시각화하면 스프레드시트나 다른 텍스트 기반 매체에 있는 것보다 훨씬 더 빨리 추세를 볼 수 있다. 예를 들어, 특정 빌드에 대해 단일 작업을 완료하는 시간을 표시하여 빌드에서 빌드까지 성능이 향상되는지 또는 감소하는지 확인할 수 있다. 동일한 이정표 집합에 대해 여러 데이터 집합을 배치하면 추세가 드러날 수 있으며 성능이 증가하거나 감소하는 이유에 대한 통찰력을 제공할 수 있다.

**Analyze Higher-Level Algorithms**

성능 데이터를 분석할 때 문제가 있는 추상화 수준에 대해 열린 마음을 유지하라. 데이터가 특정 함수 내에서 많은 시간을 소비한다고 가정하라. 함수 자체의 코드가 최적화되어 더 빠른 성능을 발휘할 수 있기 때문일 수 있다. 하지만 그것이 문제의 진짜 원인인가? 프로그램을 다시 실행하지만 이번에는 함수가 호출되는 횟수를 확인하라. 만약 그 함수를 백만 번 호출한다면, 문제는 애초에 그것을 부르고 있는 보다 고수준의 알고리즘에 있을 수 있다. 함수를 한 번 호출하면 함수의 본체가 문제일 가능성이 크다.

> **참고:** 인스트루먼트는 프로그램의 런타임 동작을 분석하는 강력한 도구이다. 인스트루먼트를 사용하면 여러 메트릭을 기록하고 나란히 표시하여 추세를 훨씬 쉽게 파악할 수 있다. 인스트루먼트의 데이터 마이닝 능력은 상위 수준의 알고리즘에서 문제를 신속하게 식별하는 또 다른 훌륭한 방법이다. 인스트루먼트 및 기타 Apple 제공 도구에 대한 자세한 내용은 [Performance Tools](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/PerformanceTools/PerformanceTools.html#//apple_ref/doc/uid/TP40001410-CH205-BCIIHAAJ)를 참조하라.

성능 도구 자체에는 데이터를 분석할 때 이해하고 고려해야 할 한계가 있다. 예를 들어, 샘플링 프로그램은 애플리케이션이 많은 시간을 소비하는 장소를 가리킬 수 있지만, 너무 많은 결론을 도출하기 전에 이러한 도구들이 데이터를 수집하는 방법을 이해해야 한다. 샘플링 도구는 모든 함수 호출을 추적하지 않는다. 대신, 그들은 고정된 간격으로 가져온 샘플을 바탕으로 프로그램에 대한 통계적 분석을 제공한다. 이러한 도구의 출력을 가이드로 사용하되, 기록한 다른 데이터와 상호 연관시켜라.

**Other Analysis Techniques**

만약 당신이 성능 문제의 진짜 원인에 대해 의심을 품는다면, 문제의 원인에 대해 가정하는 것을 피하라. 대신, 데이터 수집 작업을 관련 코드에 집중하여 분석을 구체화하라. 다른 도구를 사용하여 새로운 유형의 정보를 수집해 보라. 다른 도구는 실제 문제에 대해 더 많은 것을 드러내는 독특한 관점을 제공할 수 있다.

프로그램을 분석할 수 있는 몇 가지 추가 방법에는 다음이 포함된다:

* 디버거에서 코드를 확인하라. 디버거에서 코드를 통과하면 코드 속도를 늦추는 논리 오류가 나타날 수 있다.
* 코드가 실행된 시기에 대한 정보를 기록하려면 코드에 체크포인트를 추가하라. 체크포인트를 사용하여 초기화 코드를 추적하는 예는 [_Launch Time Performance Guidelines_](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/LaunchTime/LaunchTime.html#//apple_ref/doc/uid/10000148i)를 참조하라.
* 문제에 대한 대체 솔루션을 코딩하여 비슷한 문제에 부딪히는지 확인하라.



