# Synchronization

애플리케이션에 멀티 쓰레드가 존재하면 멀티 쓰레드 실행에서 리소스에 대한 안전한 접근에 관한 잠재적 문제가 발생한다. 동일한 리소스를 수정하는 두 개의 쓰레드가 의도하지 않은 방식으로 서로 간섭할 수 있다. 예를 들어, 한 쓰레드는 다른 쓰레드의 변경사항을 덮어쓰거나, 애플리케이션을 알 수 없고 잠재적으로 잘못된 상태로 만들 수 있다. 운이 좋다면, 손상된 리소스는 비교적 추적하고 고치기 쉬운 명백한 성능 문제나 충돌을 일으킬 수 있다. 그러나 운이 좋지 않다면, 그 부패는 훨씬 더 늦을 때까지 드러나지 않는 미묘한 오류를 야기할 수 있고, 혹은 그 오류는 당신의 근본적인 코딩 가정을 크게 재검토해야 할 수도 있다.

쓰레드의 안전성에 관해서라면 좋은 디자인은 당신이 갖는 최고의 보호책이다. 공유 리소스를 피하고 쓰레드 간의 상호작용을 최소화하면 해당 쓰레드가 서로 간섭할 가능성이 낮아진다. 그러나 완전히 간섭 없는 설계가 항상 가능한 것은 아니다. 쓰레드가 상호 작용해야 하는 경우 동기화 도구를 사용하여 쓰레드가 상호 작용할 때 안전하게 작동하도록 보장해야 한다.

OS X 및 iOS는 상호 배타적인 접근을 제공하는 도구에서부터 애플리케이션에서 이벤트를 올바르게 시퀀스하는 도구에 이르기까지 사용할 수 있는 수많은 동기화 도구를 제공한다. 다음 섹션에서는 이러한 도구와 이를 코드로 사용하여 프로그램 리소스에 대한 완전한 접근에 영향을 미치는 방법을 설명한다.

### Synchronization Tools

서로 다른 쓰레드가 예상치 않게 데이터를 변경하지 않도록 하려면 동기화 문제가 없도록 애플리케이션을 설계하거나 동기화 도구를 사용할 수 있다. 동기화 문제를 완전히 피하는 것이 바람직하지만 항상 가능한 것은 아니다. 다음 섹션에서는 사용할 수 있는 동기화 도구의 기본 범주에 대해 설명한다.

#### Atomic Operations

원자적 작업은 단순한 데이터 타입에 작용하는 단순한 형태의 동기화다. 원자 작업의 장점은 경쟁하는 쓰레드를 차단하지 않는다는 것이다. 카운터 변수를 증가시키는 것과 간단한 작업의 경우, 이것은 락을 거는 것보다 훨씬 더 나은 성능을 가져올 수 있다.

OS X와 iOS에는 32비트 및 64비트 값에 대한 기본적인 수학적, 논리적 연산을 수행하기 위한 수 많은 연산이 포함되어 있다. 이 작업들 중에는 비교-스왑, 시험-설정 및 시험-정확한 운용의 원자 작업이 있다. 지원되는 원자적 작업 목록은 `/usr/include/libkern/OSAtomic.h` 헤더 파일 또는 [atomic](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/atomic.3.html#//apple_ref/doc/man/3/atomic) 메뉴얼 페이지를 참조하라.

#### Memory Barriers and Volatile Variables

최적의 성능을 달성하기 위해 컴파일러는 종종 프로세서의 명령 파이프라인을 가능한 한 꽉 채우기 위해 어셈블리 수준의 지침을 재주문한다. 이 최적화의 일환으로, 컴파일러는 잘못된 데이터를 생성하지 않는다고 생각할 때 메인 메모리에 접근하는 지시사항을 다시 정렬할 수 있다. 불행히도, 컴파일러는 모든 메모리 의존적 작동을 감지하는 것이 항상 가능한 것은 아니다. 겉보기에는 별개의 변수가 실제로 서로 영향을 미치는 경우 컴파일러 최적화는 그러한 변수를 잘못된 순서로 업데이트하여 잠재적으로 잘못된 결과를 생성할 수 있다.

메모리 베리어는 메모리 작업이 올바른 순서로 수행되도록 하는 데 사용되는 논블로킹 동기화 도구의 일종이다. 메모리 베리어는 울타리처럼 작용하여 프로세서가 장애물 뒤에 배치된 부하 및 저장 작업을 수행하기 전에 장애물 앞에 배치된 부하 및 저장 작업을 완료하도록 한다. 메모리 베리어는 일반적으로 한 쓰레드에 의한 메모리 작동\(그러나 다른 쓰레드에 의해 보이는\)이 상항 예상된 순서로 발생하도록 보장하기 위해 사용된다. 이러한 상황에서 메모리 베리어가 부족하면 다른 쓰레드들도 불가능해 보이는 결과를 볼 수 있다. \(예를 들어, [memory barriers](http://en.wikipedia.org/wiki/Memory_barrier)에 대한 위키피디아 항목을 참조하라.\) 메모리 베리어를 사용하려면 코드의 해당 지점에서 `OSMemoryBarrier`함수를 호출하면 된다.

휘발성 변수는 개별 변수에 다른 유형의 메모리 제약 조건을 적용한다. 컴파일러는 변수에 대한 값을 레지스터에 로드하여 코드를 최적화하는 경우가 많다. 지역 변수의 경우, 이것은 보통 문제가 되지 않는다. 그러나 변수가 다른 쓰레드에서 보이는 경우, 그러한 최적화는 다른 쓰레드가 다른 쓰레드의 변화를 알아차리지 못하게 할 수 있다. 변수에 `volatile` 키워드를 적용하면 컴파일러는 사용할 때마다 메모리에서 해당 변수를 로드하게 된다. 변수의 값이 컴파일러에서 감지할 수 없는 외부 소스에 의해 언제든지 변경될 수 있다면 당신은 변수를 `volatile`로 선언할 수 있다.

메모리 베리어와 volatile 변수 모두 컴파일러가 수행할 수 있는 최적화 수를 감소시키므로, 정확성을 보장하기 위해 필요한 경우에만 메모리 베리어를 사용해야 한다. 메모리 베리어 사용에 대한 자세한 내용은 [`OSMemoryBarrier`](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/OSMemoryBarrier.3.html#//apple_ref/doc/man/3/OSMemoryBarrier) 메뉴얼 페이지를 참조하라.

#### Locks

락은 가장 일반적으로 사용되는 동기화 도구 중 하나이다. 당신은 락을 사용하여 당신의 코드의 _크리티컬 섹션_을 보호할 수 있다. 예를 들어, 크리티컬 섹션은 특정 데이터 구조를 조작하거나 한 번에 한 클라이언트에서 지원하는 일부 리소스를 사용할 수 있다. 이 섹션 주위에 락을 설치하면 다른 쓰레드가 코드의 정확성에 영향을 줄 수 있는 변경을 하지 못하게 된다.

Table 4-1은 프로그래머들이 흔히 사용하는 락의 일부를 나열한다. OS X 및 iOS는 이러한 락 유형 대부분에 대한 구현을 제공하지만 모두 제공하지는 않는다. 지원되지 않는 락 유형에 대해, 설명 컬럼은 플랫폼에서 이러한 락이 직접 구현되지 않는 이유를 설명한다.

**Table 4-1** Lock types

| Lock | Description |
| :--- | :--- |
| Mutex | 상호 배타적\(또는 뮤텍스\) 락은 자원 주위의 보호 장벽 역할을 한다. 뮤텍스는 한 번에 하나의 쓰레드에 대한 접근 권한을 부여하는 세마포어의 일종이다. 뮤텍스를 사용 중이고 다른 쓰레드가 이를 획득하려고 하면 원래 홀더에 의해 뮤텍스가 해제될 때까지 쓰레드가 차단된다. 여러 개의 쓰레드가 동일한 뮤텍스를 위해 경쟁하는 경우, 한 번에 한 개의 이 쓰레드에 접근할 수 있다. |
| Recursive lock | 재귀 락은 뮤텍스 락의 변형이다. 재귀 락은 단일 쓰레드가 락을 해제하기 전에 여러 번 락을 획득할 수 있도록 한다. 락의 소유자가 락을 획득한 횟수와 동일한 횟수만큼 락을 해제할 때까지 다른 쓰레드는 차단된 상태를 유지한다. 재귀 락은 주로 재귀 반복 중에 사용되지만, 복수의 메서드가 각각 개별적으로 락을 획득해야 하는 경우에도 사용될 수 있다. |
| Read-write lock | 읽기-쓰기 락은 공유 독점 락이라고도 한다. 이러한 유형의 락은 일반적으로 대규모 작업에 사용되며 보호된 데이터 구조를 자주 읽고 가끔만 수정하면 성능이 크게 향상될 수 있다. 정상 작업 중 복수의 판독기가 데이터 구조에 동시에 접근할 수 있다. 그러나, 한 쓰레드가 구조체에 쓰기를 원할 떄는 모든 판독기가 락을 해제할 때까지 차단되며, 이때 그것은 락을 획득하고 구조체를 업데이트할 수 있다. 쓰기 쓰레드가 락을 기다리는 동안 새로운 판독기 쓰레드는 쓰기 쓰레드가 완료될 때까지 차단된다. 시스템은 POSIX 쓰레드만을 사용하여 읽기-쓰기 락을 지원한다. 이러한 락의 사용 방법에 대한 자세한 내용은 [pthread](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread) 메뉴얼 페이지를 참조하라. |
| Distributed lock | 분산 락은 프로세스 수준에서 상호 배타적인 락을 제공한다. 실제 뮤텍스와 달리 분산 락은 프로세스를 차단하거나 프로세스를 실행하지 못하게 하지 않는다. 그것은 단순히 락이 사용중일 때 보고하고 그 프로세스가 어떻게 진행될지 결정하게 한다. |
| Spin lock | 스핀 락은 해당 조건이 참이 될 때까지 락 상태를 반복해서 폴링한다. 스핀 락은 락에 대한 예상 대기시간이 적은 멀티프로세서 시스템에 가장 많이 사용된다. 이러한 상황에서는 컨텍스트 스위치와 쓰레드 데이터 구조의 업데이트가 수반되는 쓰레드를 차단하는 것보다 폴링하는 것이 더 효율적이다. 이 시스템은 스핀 락 장치의 폴링 특성 때문에 스핀 락 장치의 구현을 제공하지 않지만, 특정 상황에서 쉽게 실행할 수 있다. 커널에서 스핀 락 구현에 대한 자세한 내용은 [_Kernel Programming Guide_](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905)를 참조하라. |
| Double-checked lock | 이중 체크된 락은 락을 취하기 전에 락 기준을 테스트함으로써 락의 오버헤드를 줄이기 위한 시도이다. 이중 체크된 락은 잠재적으로 안전하지 않기 때문에 시스템은 그러한 락에 대한 명시적인 지원을 제공하지 않으며 그 사용은 중단된다. |

> **참고**: 대부분의 락에는 또한 중요한 섹션에 들어가기 전에 선행 부하 및 저장 지침이 완료되도록 메모리 장벽이 내장되어 있다.

락 사용 방법에 대한 자세한 내용은 [Using Locks](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW16)을 참조하라

#### Conditions

조건은 어떤 조건이 참일 때 쓰레드가 서로 신호를 보낼 수 있도록 하는 또 다른 형태의 세마포어이다. 조건은 일반적으로 자원의 가용성을 표시하거나 특정 순서로 태스크가 수행되는지 확인하기 위해 사용된다. 쓰레드가 조건을 테스트할 때 그 조건이 이미 참이 아닌 한 차단한다. 다른 쓰레드가 명시적으로 변경되어 상태를 신호할 때까지 차단 상태를 유지한다. 조건과 뮤텍스 락의 차이점은 멀티 쓰레드가 동시에 조건에 접근할 수 있다는 것이다. 이 조건은 어떤 특정한 기준에 따라 다른 쓰레드가 게이트를 통과하도록 허용하는 문지기에 가깝다.

조건을 사용할 수 있는 한 가지 방법은 보류 중인 이벤트 풀을 관리하는 것이다. 이벤트 큐는 큐에 이벤트가 있을 때 대기 쓰레드를 신호하기 위해 조건 변수를 사용한다. 하나의 이벤트가 도착하면 큐는 조건을 적절하게 알린다. 쓰레드가 이미 기다리고 있다면, 그것은 큐에서 이벤트를 끌어 당겨서 처리할 때 깨울 것이다. 두 개의 이벤트가 대략 같은 시간에 큐에 들어오면 큐는 두 개의 쓰레드를 깨우기 위해 조건을 두 번 알린다.

이 시스템은 여러 가지 다른 기술에서 조건에 대한 지원을 제공한다. 그러나 정확한 조건의 구현에는 신중한 코딩이 필요하므로 자신의 코드로 사용하기 전에 [Using Conditions](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW4)를 살펴봐야 한다.

#### Perform Selector Routines

코코아 애플리케이션은 메시지를 단일 쓰레드에 동기화된 방식으로 전달하는 편리한 방법을 가지고 있다. [`NSObject`](https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSObject/Description.html#//apple_ref/occ/cl/NSObject)클래스는 애플리케이션의 활성 쓰레드 중 하나에서 셀렉터를 수행하는 방법을 선언한다. 이러한 메서드를 통해 쓰레드가 대상 쓰레드에 의해 동기식으로 수행될 것이라는 보장을 통해 메시지를 비동기적으로 전달할 수 있다. 예를 들어, 분산 컴퓨터의 사용 결과를 애플리케이션의 메인 쓰레드 또는 지정된 코디네이터 쓰레드에 전달하기 위해 셀렉터 메시지를 사용할 수 있다. 셀렉터를 수행하기 위한 각 요청은 대상 쓰레드의 런 루프에 대기하고 요청은 수신된 순서대로 순차적으로 처리된다.

셀렉터 루틴 수행에 대한 요약 및 사용 방법에 대한 자세한 내용은 [Cocoa Perform Selector Sources](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW44)를 참조하라.



