# Concurrency and Application Design

컴퓨팅 초기에는 컴퓨터가 수행할 수 있는 시간 단위당 최대 작업량을 CPU의 클럭 속도에 따라 결정하였다. 그러나 기술이 발전하고 프로세서 설계가 점점 더 복잡해지면서 열과 다른 물리적 제약이 프로세서의 최대 클럭 속도를 제한하기 시작했다. 그래서 칩 제조업체들은 칩의 총 성능을 증가시키기 위한 다른 방법들을 찾았다. 이들이 정착한 솔루션은 각 칩의 프로세서 코어 수를 늘리는 것이였다. 코어 수를 늘림으로써, 단일 칩은 CPU 속도를 높이거나 칩 크기나 열 특성을 바꾸지 않고도 초당 더 많은 명령을 실행할 수 있었다. 유일한 문제는 추가 코어를 활용하는 방법이었다.

여러 코어를 활용하려면, 컴퓨터는 여러 가지를 동시에 할 수 있는 소프트웨어가 필요하다. OS X와 iOS와 같은 현대의 멀티태스킹 운영체제의 경우, 주어진 시간에 100개 이상의 프로그램이 실행될 수 있으므로, 다른 코어에 있는 각 프로그램이 스케줄 가능해야 한다. 그러나 이러한 프로그램의 대부분은 실제 처리 시간을 거의 소비하지 않는 시스템 데몬 또는 백그라운드 애플리케이션이다. 대신, 정말로 필요한 것은 개별 애플리케이션이 추가 코어를 더 효과적으로 사용할 수 있는 방법이다.

애플리케이션이 여러 코어를 사용하는 전통적인 방법은 여러 스레드를 생성하는 것이다. 그러나 코어 수가 증가함에 따라 스레드 솔루션에 문제가 있다. 가장 큰 문제는 스레드 코드가 임의의 코어 수로 잘 확장되지 않는다는 것이다. 프로그램이 잘 실행될 것으로 예상하여 많은 스레드를 생성할 수 없다. 우리가 알아야 할 것은 애플리케이션 자체에서 컴퓨팅하기 어려운 문제에 대해 효율적으로 사용할 수 있는 코어의 수이다. 가까스로 숫자를 맞추더라도 많은 스레드를 프로그래밍하고 효율적으로 작동시키고 서로 간섭하지 않도록 하는 것은 여전히 어려운 일이다.

그래서 이 문제를 요약하자면, 응용 프로그램이 다양한 수의 컴퓨터 코어를 활용할 수 있는 방법이 있어야 한다. 단일 애플리케이션에 의해 수행되는 작업의 양 또한 변화하는 시스템 조건에 맞게 동적으로 확장할 수 있어야 한다. 또한 이 솔루션은 이러한 코어를 활용하는 데 필요한 작업량을 늘리지 않도록 충분히 단순해야 한다. 좋은 소식은 애플의 운영체제가 이러한 모든 문제에 대한 해결책을 제공한다는 것이다.

## The Move Away from Threads

스레드는 여러 해 동안 존재해 왔고 계속해서 그 용도를 가지고 있지만, 여러 작업을 확장 가능한 방식으로 실행하는 일반적인 문제를 해결하지는 못한다. 스레드를 사용하면 개발자에게 확장 가능한 솔루션을 만들어야 하는 부담이 생긴다. 시스템 조건이 변경될 때 해당 수를 동적으로 생성하고 조정할 스레드 수를 결정해야 한다. 또 다른 문제는 애플리케이션이 사용하는 스레드 생성 및 유지 보수와 관련된 대부분의 비용을 부담한다는 것이다.

OS X와 iOS는 스레드에 의존하는 대신 동시성 문제를 해결하기 위해 비동기식 설계 방식을 채택한다. 운영체제에 비동기 함수가 여러 해 동안 존재해왔으며 디스크에서 데이터를 읽는 등 시간이 오래 걸릴 수 있는 작업을 시작하는데 종종 사용된다. 호출되면 비동기 함수는 작업 실행을 시작하지만 작업이 실제로 완료되기 전에 되돌아오도록 동작한다. 일반적으로 이 작업에는 백그라운드 스레드를 획득하고, 해당 스레드에서 원하는 작업을 시작한 다음, 작업이 완료되면 \(일반적으로 콜백 기능을 통해\) 호출자에게 알림을 보내는 작업이 포함된다. 과거에는 원하는 작업에 대해 비동기 함수가 존재하지 않는 경우 자신만의 비동기 함수를 작성하고 자신만의 스레드를 생성해야 했다. 그러나 이제 OS X와 iOS는 스레드를 직접 관리할 필요 없이 어떠한 작업도 비동기적으로 수행할 수 있는 기술을 제공한다.

작업을 비동기적으로 시작하는 기술 중 하나는 GCD\(Grand Central Dispatch\)이다. 이 기술은 일반적으로 자체 애플리케이션에서 쓰는 스레드 관리 코드를 사용하여 시스템 레벨로 이동시킨다. 실행할 태스크를 정의하고 적절한 디스패치 큐에 추가하기만 하면 된다. GCD는 필요한 스레드를 생성하고 이러한 스레드에서 작업을 실행하도록 예약하는 작업을 처리한다. 스레드 관리는 이제 시스템의 일부이기 때문에 GCD는 작업 관리와 실행에 대한 전체적인 접근 방식을 제공하여 기존의 스레드보다 더 나은 효율성을 제공한다.

오퍼레이션 큐은 디스패치 큐과 매우 유사한 역할을 하는 Objective-C 객체이다. 실행할 태스크를 정의한 다음 이러한 태스크의 예약 및 실행을 처리하는 작업 큐에 추가한다. GCD와 마찬가지로 오퍼레이션 큐도 모든 스레드 관리를 처리하여 시스템에서 작업이 최대한 신속하고 효율적으로 실행되도록 보장한다.

다음 섹션에서는 응용 프로그램에서 사용할 수 있는 디스패치 큐, 오퍼레이션 큐 및 기타 관련 비동기 기술에 대한 자세한 정보를 제공한다.

### Dispatch Queues

디스패치 큐는 사용자 지정 태스크를 실행하기 위한 C 기반 메커니즘이다. 디스패치 큐는 연속적으로 또는 동시에 작업을 실행하지만 항상 FIFO 순서에 따라 실행한다. \(즉, 디스패치 큐는 항상 대기열에 추가된 것과 동일한 순서로 작업을 대기열에서 시작한다.\) 시리얼 디스패치 큐는 한 번에 하나의 작업만 실행하고, 작업이 완료될 때까지 기다렸다가 새 작업을 시작한다. 이와는 대조적으로, 콘커런트 디스패치 큐는 이미 시작된 작업이 완료될 때까지 기다리지 않고 최대한 많은 작업을 시작한다.

디스패치 큐는 그 밖의 이점이 있다.

* 직관적이고 간단한 프로그래밍 인터페이스를 제공한다.
* 자동적이고 전체적인 스레드 풀 관리를 제공한다.
* 튜닝된 어셈블리 속도를 제공한다.
* 훨씬 더 메모리 효율적이다. \(스레드 스택은 애플리케이션 메모리에 남아있지 않기 때문이다.\)
* 부하가 걸린 상태에서 커널에 함정을 놓지 않는다.
* 디스패치 큐에 대한 작업의 비동기적 발송은 큐를 교착시킬 수 없다.
* 논쟁 중에 우아하게 규모를 조정한다.
* 시리얼 디스패치 큐는 락 및 기타 동기화 기본 요소에 대한 보다 효율적인 대안을 제공한다.

디스패치 큐에 제출하는 태스크는 함수 또는 block object 내부에 캡슐화되어야 한다. Block objects는 OS X v10.6 및 iOS 4.0에 도입된 C 언어 기능으로 개념적으로 기능 포인터와 유사하지만 몇 가지 추가적인 장점이 있다. 블록을 자체 어휘 범위에서 정의하는 대신, 일반적으로 다른 함수나 메소드 내부에 블록을 정의하여 해당 함수나 메서드에서 다른 변수에 접근할 수 있도록 한다. 블록을 원래 범위에서 벗어나 힙에 복사할 수도 있으며, 이는 블록을 디스패치 대기열에 제출할 때 발생하는 현상이다. 이 모든 의미론들은 비교적 적은 코드로 매우 역동적인 작업을 구현할 수 있게 해준다.

디스패치 큐는 Grand Central Dispatch 기술의 일부분이며 C 런타임의 일부분이다. 애플리케이션에서 디스패치 큐 사용에 대한 자세한 내용은 Dispatch Queues를 참조하라. 블록 및 해당 이점에 대한 자세한 내용은 Blocks Programming Topics를 참조하라.

### Dispatch Sources

디스패치 소스는 특정 유형의 시스템 이벤트를 비동기식으로 처리하기 위한 C 기반 메커니즘이다. 디스패치 소스는 특정 유형의 시스템 이벤트에 대한 정보를 캡슐화하여 이벤트가 발생할 때마다 특정 block object 또는 함수를 디스패치 큐에 제출한다. 다음 유형의 시스템 이벤트를 모니터링하기 위해 디스패치 소스를 사용할 수 있다.

* 타이머
* 신호 핸들러
* 설명자 관련 이벤트
* 프로세스 관련 이벤트
* Mach 포트 이벤트
* 트리거하는 사용자 정의 이벤트

디스패치 소스는 Grand Central Dispatch 기술의 일부이다. 애플리케이션에서 이벤트를 수신하기 위해 디스패치 소스를 사용하는 방법에 대한 자세한 내용은 Dispatch Sources를 참조하라.

### Operation Queues

오퍼레이션 큐는 Cocoa의 콘커런트 큐와 동등하며 `NSOperationQueue` 클래스에 의해 구현된다. 디스패치 큐는 항상 FIFO 순서로 작업을 실행하는 반면, 오퍼레이션 큐는 작업의 실행 순서를 결정할 때 다른 요소를 고려한다. 이러한 요소들 중 가장 중요한 것은 주어진 태스크가 다른 태스크의 완료에 따라 달라지는가 하는 것이다. 태스크를 정의할 때 의존성을 구성하고 이를 사용하여 태스크에 대한 복잡한 실행 순서 그래프를 생성할 수 있다.

오퍼레이션 큐에 제출하는 태스크는 `NSOperation` 클래스의 인스턴스여야 한다. 작업 객체는 수행하고자 하는 작업과 이를 수행하는 데 필요한 데이터를 캡슐화하는 Objective-C 객체이다. `NSOperation` 클래스는 기본적으로 추상 기본 클래스이므로 일반적으로 태스크를 수행할 사용자 정의 하위 클래스를 정의하라. 그러나 Foundation 프레임워크에는 태스크를 수행하는 것과 마찬가지로 작성하고 사용할 수 있는 몇 가지 구체적인 하위 클래스가 포함되어 있다.

오퍼레이션 객체가 키 값 관찰\(KVO\) 알림을 생성하며 작업 진행률을 모니터링하는 유용한 방법이다. 오퍼레이션 큐는 항상 동시에 작업을 실행하지만, 종속성을 사용하여 필요할 때 연속적으로 실행되도록 할 수 있다.

오퍼레이션 큐를 사용하는 방법과 사용자 지정 작업 객체를 정의하는 방법에 대한 자세한 내용은 Operation Queues를 참조하라.

## Asynchronous Design Techniques

동시성을 지원하기 위해 코드를 재설계하는 것을 고려하기 전에, 그렇게 하는 것이 필요한지 자문해 보아야 한다. 동시성은 메인 스레드가 사용자 이벤트에 자유롭게 응답할 수 있도록 함으로써 코드의 응답성을 향상시킬 수 있다. 이는 더 많은 코어를 활용하여 동일한 시간 내에 더 많은 작업을 수행함으로써 코드의 효율성을 향상한다. 그러나 그것은 또한 오버헤드를 추가하고 당신의 코드의 전반적인 복잡성을 증가시켜 당신의 코드를 쓰고 디버깅하는 것을 더 어렵게 만든다.

복잡성을 가중시키기 때문에 동시성은 제품 주기가 끝나면 애플리케이션에 접목할 수 있는 기능이 아니다. 제대로 하려면 애플리케이션이 수행하는 작업과 이러한 작업을 수행하는 데 사용되는 데이터 구조를 신중하게 고려해야 한다. 잘못하면 코드가 이전보다 느리게 실행되고 사용자에게 응답하지 않을 수 있다. 따라서 설계 주기의 시작에 시간을 두고 몇 가지 목표를 설정하고 취해야 할 접근방식에 대해 생각해 보는 것은 가치 있는 일이다.

모든 애플리케이션은 다른 요구사항과 다른 태스크 집합을 가지고 있다. 문서에서 애플리케이션 및 관련 태스크를 정확히 설계하는 방법을 알려주는 것은 불가능하다. 그러나 다음 절에서는 설계 프로세스 중에 좋은 선택을 하는 데 도움이 되는 몇가지 가이드라인을 제공하려고 한다.

### Define Your Application’s Expected Behavior

애플리케이션에 동시성을 추가하는 것을 고려하기 전에 항상 애플리케이션의 올바른 동작으로 간주하는 것을 정의하는 것부터 시작해야 한다. 애플리케이션의 예상 동작을 이해하면 나중에 설계를 검증할 수 있다. 또한 동시성 도입으로 얻을 수 있는 예상 성능상의 이점을 어느정도 파악할 수 있어야 한다.

가장 먼저 해야 할 일은 애플리케이션이 수행하는 작업과 각 작업과 관련된 객체 또는 데이터 구조를 열거하는 것이다. 처음에는 사용자가 메뉴 항목을 선택하거나 버튼을 클릭할 때 수행되는 작업으로 시작하길 원할 것이다. 이러한 작업은 별개의 동작을 제공하며 시작점과 끝점이 잘 정의되어 있다. 또한 타이머 기반 태스크와 같이 사용자 상호 작용 없이 응용 프로그램이 수행할 수 있는 다른 유형의 태스크도 열거하라.

하이 레벨 태스크 목록을 확보한 후 각 태스크를 성공적으로 완료하기 위해 수행해야 하는 단계 집합으로 세분화하라. 이 수준에서는 데이터 구조와 객체를 수정하는데 필요한 수정 사항과 이러한 수정 사항이 애플리케이션의 전체 상태에 어떤 영향을 미치는지에 대해 우선적으로 관심을 가져야 한다. 또한 객체와 데이터 구조 간의 종속성에도 유의하라. 예를 들어, 작업에서 객체 배열을 동일하게 변경하는 작업이 포함된 경우, 한 객체의 변경이 다른 객체에 영향을 미치는지 여부를 주목할 필요가 있다. 객체를 서로 독립적으로 수정할 수 있는 경우, 동시에 수정할 수 있는 장소가 될 수 있다.

### Factor Out Executable Units of Work

애플리케이션 태스크에 대한 이해로 부터 당신은 이미 당신의 코드가 동시성으로 이익을 얻을 수 있는 장소를 식별할 수 있어야 한다. 작업에서 하나 이상의 단계의 순서를 변경하면 결과가 변경되는 경우, 이러한 단계를 연속적으로 계속 수행해야 할 수 있다. 그러나 순서를 변경해도 출력에 영향을 미치지 않는 경우 이러한 단계를 동시에 수행하는 것을 고려해야 한다. 두 경우 모두 수행할 단계 또는 단계를 나타내는 작업의 실행 단위를 정의하라. 이 작업 단위는 block 또는 작업 객체를 사용하여 캡슐화하여 적절한 대기열로 전송하는 것이 된다.

식별한 각 실행 단위에 대해 적어도 초기에 수행되는 작업의 양에 대해 걱정할 필요가 없다. 스레드를 회전시키는 데 항상 비용이 들지만, 디스패치 큐와 오퍼레이션 큐의 장점 중 하나는 대다수의 경우 그러한 비용이 기존 스레드에 비해 훨씬 적다는 것이다. 따라서 스레드를 사용할 때보다 큐를 사용하여 더 작은 단위 작업을 효율적으로 실행할 수 있다. 물론 항상 실제 성과를 측정하고 필요에 따라 태스크의 크기를 조정해야 하지만, 처음에는 어떤 태스크도 작은 것으로 간주해서는 안된다.

### Identify the Queues You Need

이제 태스크가 별개의 작업 단위로 분할되고 블록 객체 또는 작업 객체를 사용하여 캡슐화되므로 해당 코드를 실행하는 데 사용할 대기열을 정의하라. 지정된 태스크의 경우 생성한 블록 또는 작업 객체와 태스크를 올바르게 수행하기 위해 객체를 실행해야 하는 순서를 검사하라.

블록을 사용하여 태스크를 구현한 경우 시리얼 또는 컨커런트 대기열에 블록을 추가할 수 있다. 특정 주문이 필요한 경우 항상 시리얼 디스패치 큐에 블록을 추가하라. 특정 주문이 필요하지 않은 경우 블록을 컨커런트 디스패치 큐에 추가하거나 필요에 따라 여러 다른 디스패치 큐에 추가할 수 있다.

작업 객체를 사용하여 태스크를 구현한 경우 큐의 선택이 객체의 구성보다 덜 흥미로운 경우가 많다. 작업 객체를 연속적으로 수행하려면 관련 객체 간에 의존성을 구성해야 한다. 의존성은 한 작업이 의존된 객체가 작업을 마칠 때까지 실행되지 못하게 한다.

### Tips for Improving Efficiency

단순히 코드를 작은 태스크로 간주하여 큐에 추가하는 것 외에도 큐를 사용하여 코드의 전반적인 효율성을 향상시키는 다른 방법이 있다.

* **메모리 사용량이 요인인 경우 태스크 내에서 직접 값을 계산하라**. 애플리케이션이 이미 메모리 바인딩되어 있는 경우, 지금 바로 계산하는 것이 메인 메모리에서 캐시된 값을 로드하는 것보다 빠를 수 있다. 컴퓨팅 값은 메인 메모리보다 훨씬 빠른 지정된 프로세서 코어의 레지스터와 캐시를 직접 사용한다. 물론, 테스트 결과 이것이 성능상으로 우위일 때 이것을 해야 한다.
* **시리얼 태스크를 조기에 파악하여 더 많은 동시 작업을 수행할 수 있도록 하라.** 태스크가 일부 공유 리소스에 의존하기 때문에 태스크를 연속적으로 실행해야 하는 경우 해당 공유 리소스를 제거하도록 아키텍처를 변경하라. 필요한 각 클라이언트에 대한 리소스 복사본을 만들거나 리소스를 모두 제거하는 것을 고려할 수 있다.
* **락을 사용하지 않아야 한다.** 디스패치 큐와 오퍼레이션 큐에서 제공하는 지원은 대부분의 상황에서 락을 불필요하게 만든다. 일부 공유 리소스를 보호하기 위해 락을 사용하는 대신 올바른 순서로 작업을 실행하기 위해 시리얼 큐\(또는 작업 개체 종속성\)을 지정하라.
* **가능할 때마다 시스템 프레임워크를 활용하라.** 동시성을 달성하는 가장 좋은 방법은 시스템 프레임워크가 제공하는 내장된 동시성을 이용하는 것이다. 많은 프레임워크가 내부적으로 스레드 및 기타 기술을 사용하여 동시 동작을 구현한다. 태스크를 정의할 때 기존 프레임워크가 사용자가 원하는 것과 동시에 수행하는 기능 또는 메서드를 정의하는지 확인하라. 그 API를 사용하면 노력을 절약할 수 있고 가능한 한 최대한의 동시성을 얻을 수 있다.

## Performance Implications

더 많은 코드를 동시에 실행할 수 있도록 오퍼레이션 큐, 디스패치 큐 및 디스패치 소스가 제공된다. 그러나 이러한 기술은 애플리케이션의 효율성 또는 응답성 향상을 보장하지 않는다. 여전히 당신의 필요에 효과적이고 당신의 애플리케이션의 다른 자원에 과도한 부담을 주지 않는 방법으로 대기열을 사용하는 것은 당신의 책임이다. 예를 들어, 작업 객체를 10000개 생성하여 오퍼레이션 큐에 제출할 수 있지만, 그렇게 하면 애플리케이션이 잠재적으로 비독점적인 양의 메모리를 할당하게 되고, 이로 인해 페이징이 발생하고 성능이 저하될 수 있다.

큐나 스레드를 사용하든 상관없이 코드에 어느 정도의 동시성을 도입하기 전에 애플리에키션의 현재 성능을 반영하는 기준 메트릭 셋을 항상 수집해야 한다. 변경 사항을 도입한 후에는 추가 메트릭을 수집하여 기준과 비교하여 애플리케이션의 전반적인 효율성이 향상되었는지 확인하라. 동시성 도입으로 애플리케이션의 효율성과 응답성이 저하되는 경우 사용 가능한 성능 툴을 사용하여 잠재적인 원인을 확인하라.

성능 및 사용가능한 성능 툴에 대한 소개와 고급 성능 관련 항목에 대한 링크는 Performance Overview를 참조하라.

## Concurrency and Other Technologies

코드를 모듈형 작업으로 변환하는 것이 애플리케이션의 동시성을 향상시키기 위한 최선의 방법이다. 그러나 이 설계 접근방식은 모든 경우에 모든 애플리케이션의 요구를 충족시키지 못할 수 있다. 작업에 따라 애플리케이션 전체 동시성을 추가로 개선할 수 있는 옵션이 있을 수 있다. 이 섹션에서는 설계의 일부로 사용할 수 있는 기타 기술에 대해 개략적으로 설명한다.

### OpenCL and Concurrency

OS X에서 Open Computing Language\(OpenCL\)는 컴퓨터의 그래픽 프로세서에서 범용 계산을 수행하는 표준 기반 기술이다. OpenCL은 대규모 데이터 셋에 적용하고자 하는 잘 정의된 계산 집합이 있는 경우 사용하기 좋은 기술이다. 예를 들어 OpenCL을 사용하여 한 영상의 픽셀에 대해 필터 계산을 수행하거나 여러 값에 대해 복잡한 산술 계산을 한 번에 수행할 수 있다. 즉, OpenCL은 데이터를 병렬로 작동할 수 있는 문제 집합에 더 적합하다.

OpenCL은 대규모 데이터 병렬 연산을 수행하기에 좋지만, 보다 범용적인 계산에는 적합하지 않다. GPU에 의해 작동될 수 있도록 데이터와 필요한 작업 커널을 준비하고 그래픽 카드로 전송하는 데 필요한 비타분적인 노력이 있다. 마찬가지로 OpenCL에서 생성된 결과를 검색하는 데 필요한 비타당적인 노력이 있다. 따라서 시스템과 상호 작용하는 작업은 일반적으로 OpenCL과 함께 사용하지 않는 것이 좋다. 예를 들어 파일 또는 네트워크 스트림의 데이터를 처리하기 위해 OpenCL을 사용하지 않을 경우가 있다. 대신, OpenCL을 사용하여 수행하는 작업은 그래픽 프로세서로 전송되고 독립적으로 계산될 수 있도록 훨씬 더 독립적이어야 한다.

OpenCL과 OpenCL 사용 방법에 대한 자세한 내용은 OpenCL Programming Guide for Mac을 참조하라.

### When to Use Threads

오퍼레이션 큐와 디스패치 큐가 동시에 작업을 수행하는 데 선호되는 방식이지만 만병통치약은 아니다. 애플리케이션에 따라 사용자 지정 스레드를 생성해야 하는 경우가 여전히 있을 수 있다. 만약 사용자 정의 스레드를 만든다면, 당신은 가능한 한 적은 수의 스레드를 만들기 위해 노력해야 하며, 당신은 다른 어떤 방법으로도 구현될 수 없는 특정한 작업에만 그 스레드를 사용해야 한다.

스레드는 여전히 실시간으로 실행되어야 하는 코드를 구현하는 좋은 방법이다. 디스패치 큐에서는 모든 작업을 가능한 한 빨리 실행하려고 하지만 실시간 제약을 해결하지는 않는다. 백그라운드에서 실행되는 코드에서 보다 예측 가능한 동작이 필요한 경우 스레드는 여전히 더 나은 대안을 제공할 수 있다.

스레드 프로그래밍과 마찬가지로 반드시 필요할 때만 스레드를 현명하게 사용해야 한다. 스레드 패키지 및 스레드 사용 방법에 대한 자세한 내용은 Threading Programming Guide를 참조하라.

