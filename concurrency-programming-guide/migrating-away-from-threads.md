# Migrating Away from Threads

기존의 쓰레드 코드를 Grand Central Dispatch 및 Operation 객체를 이용하도록 조정하는 방법은 많다. 비록 쓰레드에서 벗어나는 것은 모든 경우에 불가능할 수 있지만, 당신이 스위치를 만드는 장소에서는 성능 \(및 당신의 코드의 단순성\)이 극적으로 향상될 수 있다. 특히, 쓰레드 대신 디스패치 큐와 오퍼레이션 큐를 사용하는 것은 다음과 같은 몇 가지 이점이 있다.

* 애플리케이션이 애플리케이션의 메모리 공간에 쓰레드 스택을 저장하는 데 지불하는 메모리 패널티를 줄인다.
* 쓰레드를 생성하고 구성하는 데 필요한 코드를 제거하라.
* 쓰레드 작업을 관리하고 스케줄링하는 데 필요한 코드를 제거한다.
* 당신이 작성해야할 코드를 단순화한다.

이 장에서는 기존 쓰레드 기반 코드를 교체하고 대신 디스패치 큐와 오퍼레이션 큐를 사용하여 동일한 유형의 동작을 수행하는 방법에 대한 몇 가지 팁과 가이드를 제공한다.

### 디스패치 큐로 쓰레드 교체

쓰레드를 디스패치 큐로 대체하는 방법을 이해하려면 먼저 애플리케이션에서 쓰레드를 사용할 수 있는 몇 가지 방법을 고려하라.

* **단일 태스크 쓰레드.** 단일 태스크를 수행하기 위한 쓰레드를 생성하고 태스크가 완료되면 쓰레드를 릴리즈하라.
* **워커 쓰레드.** 각 태스크에 대해 특정 작업을 염두에 두고 하나 이상의 워커 쓰레드를 생성한다. 태스크를 각 쓰레드에 주기적으로 전송한다.
* **쓰레드 풀.** 일반 쓰레드 풀을 생성하고 런 루프를 각각 설정하라. 수행할 태스크가 있으면 풀에서 쓰레드를 가져와 태스크를 해당 태스크로 전송하라. 사용 가능한 쓰레드가 없는 경우 태스크를 대기하고 쓰레드를 사용할 수 있을 때까지 기다려라. 

비록 이것들이 극적으로 다른 기술처럼 보일지 모르지만, 그것들은 실제로 같은 원리에 근거한 변형일 뿐이다 각각의 경우, 쓰레드는 애플리케이션이 수행해야 하는 일부 태스크를 실행하기 위해 사용된다. 그것들 사이의 유일한 차이점은 쓰레드와 태스크의 큐를 관리하는 데 사용되는 코드다. 디스패치 큐와 오퍼레이션 큐를 사용하면 쓰레드 및 쓰레드 통신 코드를 모두 제거하고 대신 수행하고자 하는 태스크에만 집중할 수 있다.

위의 쓰레드 모델 중 하나를 사용하는 경우 애플리케이션이 수행하는 태스크의 유형에 대해 이미 상당히 잘 알고 있어야 한다. 사용자 지정 쓰레드 중 하나에 태스크를 제출하는 대신 해당 태스크를 작업 객체 또는 블록 객체에 캡슐화한 후 적절한 큐에 발송하라. 특별히 논란이 되지 않는 태스크, 즉 락을 사용하지 않는 태스크의 경우 다음과 같은 직접 교체를 할 수 있다:

* 단일 태스크 쓰레드의 경우, 태스크를 블록 또는 오퍼레이션 객체로 캡슐화한 후 콘커런트 큐에 제출하라.
* 워커 쓰레드의 경우, 시리얼 큐를 사용할지, 콘커런트 큐를 사용할지 결정해야 한다. 워커 쓰레드를 사용하여 특정 태스크 집합의 실행을 동기화하는 경우 시리얼 큐를 사용하라. 워커 쓰레드를 사용하여 상호 종속성 없이 임의 태스크를 실행하는 경우 콘커런트 큐를 사용하라.
* 쓰레드 풀의 경우 블록의 태스크 또는 오퍼레이션 객체를 캡슐화한 후 실행을 위해 콘커런트 큐로 전송하라.

물론, 이와 같은 간단한 교체는 모든 경우에 효과가 없을 수 있다. 실행 중인 태스크가 공유 리소스를 실행하는 경우, 이상적인 해결책은 먼저 해당 경합을 제거하거나 최소화하는 것이다. 공유 리소스에 대한 상호 의존성을 제거하기 위해 코드를 리팩토링하거나 재구성할 수 있는 방법이 있다면, 그것은 확실히 바람직하다. 그러나, 그렇게 하는 것이 가능하지 않거나 덜 효율적일 수 있다면, 여전히 큐를 이용할 수 있는 방법이 있다. 큐의 큰 장점은 코드를 실행할 수 있는 보다 예측 가능한 방법을 제공한다는 것이다. 이 예측가능성은 락이나 다른 헤비급 동기화 메커니즘을 사용하지 않고 코드의 실행을 동기화할 수 있는 방법이 여전히 있다는 것을 의미한다. 락을 사용하는 대신 큐를 사용하여 동일한 태스크를 여러 개 수행할 수 있다:

* 특정 순서로 실행해야 하는 태스크가 있는 경우 해당 태스크를 시리얼 디스패치 큐에 제출하라. 오퍼레이션 큐를 사용하려면 오퍼레이션 객체 종속성을 사용하여 해당 객체가 특정 순서로 실행되도록 하라.
* 현재 락을 사용하여 공유 리소스를 보호할 경우, 해당 리소스를 수정하는 태스크를 실행하기 위해 시리얼 큐를 생성하라. 그런 다음 시리얼 큐는 동기화 메커니즘으로 기존 락을 대체한다. 락 제거에 대한 자세한 내용은 [Eliminating Lock-Based Code](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW3)를 참조하라.
* 쓰레드 조인을 사용하여 백그라운드 태스크가 완료될 때까지 기다리는 경우 디스패치 그룹을 사용하는 것을 고려하라. [`NSBlockOperation`](https://developer.apple.com/documentation/foundation/blockoperation) 객체 또는 오퍼레이션 객체 종속성을 사용하여 유사한 그룹 완료 동작을 달성할 수도 있다. 실행 중인 태스크 그룹을 추적하는 방법에 대한 자세한 내용은 [Replacing Thread Joins](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW6)를 참조하라.
* 한정된 리소스 풀을 관리하기 위해 생산자-소비자 알고리즘을 사용하는 경우, [Changing Producer-Consumer Implementations](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW7)에 표시된 구현으로 변경하는 것을 고려하라.
* 쓰레드를 사용하여 설명자를 읽고 쓰거나 파일 작업을 모니터링하는 경우 디스패치 소스에 설명된 대로 [Dispatch Sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1)를 사용하라.

큐는 쓰레드를 교체하는 만병통치약이 아니라는 것을 기억해야 한다. 큐에 의해 제공되는 비동기 프로그래밍 모델은 지연 시간이 문제가 되지 않는 상황에서 적합하다. 큐가 대기열에서 태스크의 실행 우선순위를 구성하는 방법을 제공하지만, 실행 우선순위가 높을수록 특정 시간에 태스크의 실행을 보장하지는 않는다. 따라서, 오디오나 비디오 재생과 같이 최소한의 대기 시간이 필요한 경우, 쓰레드는 여전히 더 적절한 선택이다.

### 락-기반의 코드 제거ddd

쓰레드 코드의 경우 락은 쓰레드 간에 공유되는 리소스에 대한 접근을 동기화하는 전통적인 방법 중 하나이다. 그러나 락의 사용은 비용이 든다. 비경합 사례에서도 락을 취하는 것과 관련된 성능 패널티가 항상 존재한다. 그리고 경합 사례에서 락이 풀릴 때까지 기다리는 동안 한 개 이상의 쓰레드가 일정하지 않은 시간 동안 차단될 가능성이 있다.

락 기반 코드를 큐로 대체하면 락과 관련된 많은 패널티가 제거되고 나머지 코드도 단순화된다. 공유 리소스를 보호하기 위해 락을 사용하는 대신, 해당 리소스에 접근하는 태스크를 직렬화하기 위한 큐를 만들 수 있다. 큐는 락과 같은 패널티를 부과하지 않는다. 예를 들어, 태스크를 큐에 넣는 것은 뮤텍스를 얻기 위해 커널에 트래핑할 필요가 없다.

태스크를 큐에 넣을 때 가장 중요한 결정은 동기적으로 할 것인지 비동기적으로 할 것인지를 결정하는 것이다. 태스크를 비동기적으로 제출하면 태스크가 수행되는 동안 현재 쓰레드가 계속 실행될 수 있다. 태스크를 동시에 제출하면 태스크가 완료될 때까지 현재 쓰레드가 차단된다. 두 옵션 모두 적절한 용도를 가지고 있지만, 가능할 때마다 태스크를 비동기적으로 제출하는 것이 확실히 유리하다.

다음 절에서는 기존 락 기반 코드를 동등한 큐-기반 코드로 교체하는 방법을 보여준다.

#### 비동기적인 락 구현

비동기적인 락은 해당 리소스를 수정하는 코드를 차단하지 않고 공유 리소스를 보호하는 방법이다. 데이터 구조를 수정해야 하는 경우 코드가 수행하는 다른 작업의 부작용으로 비동기적인 락을 사용할 수 있다. 전통적인 쓰레드를 사용해 일반적으로 이 코드를 구현하는 방법은 공유 리소스에 대한 락을 취하고 필요한 내용을 변경하고 락을 해제하고 태스크의 주요 부분을 계속 수행하는 것이다. 그러나, 디스패치 큐를 사용하면 호출 코드는 변경이 완료될 때 까지 기다리지 않고 비동기적으로 변경을 할 수 있다.

목록 5-1은 비동기적인 락 구현의 예를 보여준다. 이 예제에서 보호된 리소스는 자체 시리얼 큐를 정의한다. 호출 코드는 리소스를 수정해야 하는 내용이 포함된 블록 객체를 이 큐에 제출한다. 큐 자체는 블록을 연속적으로 실행하기 때문에, 수신된 순서대로 리소스에 대한 변경이 보장되지만, 태스크가 비동기적으로 실행되었기 때문에 호출 쓰레드가 차단되지 않는다.

**목록 5-1** 비동기적으로 보호된 리소스 수정

```objectivec
dispatch_async(obj->serial_queue, ^{
   // Critical section
});
```

#### 크리티컬 섹션 동기적으로 실행

주어진 태스크가 완료될 때까지 현재 코드를 계속할 수 없는 경우, [`dispatch_sync`](https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync) 함수를 사용하여 태스크를 동기적으로 제출할 수 있다. 이 함수는 태스크를 디스패치 큐에 추가한 다음 태스크 실행이 완료될 때까지 현재 쓰레드를 차단한다. 디스패치 큐 자체는 사용자의 필요에 따라 시리얼 또는 콘커런트 일 수도 있다. 그러나 이 함수는 현재 쓰레드를 차단하므로 필요할 때만 사용해야 한다. 목록 5-2는 `dispatch_sync`를 사용하여 코드의 중요한 부분을 포장하는 기술을 보여준다.

**목록 5-2** 동기적으로 크리티컬 섹션 실행

```objectivec
dispatch_sync(my_queue, ^{
   // Critical section
});
```

이미 시리얼 큐를 사용하여 공유 리소스를 보호하고 있는 경우, 해당 큐로 동기적으로 발송해도 비동기적으로 발송한 경우보다 더 이상 공유 리소스를 보호하지 않는다. 동시에 발송하는 유일한 이유는 크리티컬 섹션이 끝날 때까지 현재 코드가 계속되지 않도록 하기 위함이다. 예를 들어, 공유 리소스에서 값을 얻어 즉시 사용하고자 한다면 동기적으로 발송할 필요가 있을 것이다. 현재 코드가 크리티컬 섹션이 완료될 때까지 기다릴 필요가 없거나, 추가 후속 태스크를 동일한 시리얼 큐에 간단히 제출할 수 있는 경우 일반적으로 비동기적으로 제출하는 것이 바람직하다.

### 루프 코드 개선

만약 당신의 코드가 루프를 가지고 있고, 루프를 통해 매번 행해지는 작업이 다른 반복해는 행해지는 작업과 무관하다면, 당신은 [`dispatch_apply`](https://developer.apple.com/documentation/dispatch/1453050-dispatch_apply) 또는 [`dispatch_apply_f`](https://developer.apple.com/documentation/dispatch/1452846-dispatch_apply_f) 함수를 사용하여 루프 코드를 다시 구현하는 것을 고려할 수 있다. 이러한 함수는 루프의 각 반복을 처리를 위해 디스패치 큐에 별도로 제출한다. 콘커런트 큐와 함께 사용하면 이 기능을 통해 루프를 여러 번 동시에 수행할 수 있다.

`dispatch_apply` 및 `dispatch_apply_f` 함수는 모든 루프 반복이 완료될 때까지 현재 실행 쓰레드를 차단하는 동기적인 함수 호출이다. 콘커런트 큐에 제출될 때, 루프 반복의 실행 순서가 보장되지 않는다. 각 반복을 실행하는 쓰레드는 특정 반복을 차단하고 해당 반복을 주변 다른 반복 이전 또는 이후에 완료할 수 있다. 따라서 각 루프 반복에 사용하는 블록 객체나 함수는 재진입되어야 한다.

목록 5-3은 `for` 루프를 해당 발송-기반 등가물로 교체하는 방법을 보여준다. [`dispatch_apply`](https://developer.apple.com/documentation/dispatch/1453050-dispatch_apply) 또는 `dispatch_apply_f`에 전달되는 블록 또는 함수는 현재 루프 반복을 나타내는 정수 값을 가져야 한다. 이 예제에서, 코드는 현재 루프 번호를 콘솔에 간단히 출력한다.

**목록 5-3** striding 없이 for 루프 대체

```objectivec
queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   printf("%u\n", i);
});
```

앞의 예는 단순한 예이지만, 디스패치 큐를 사용하여 루프를 대체하는 기본 기술을 보여준다. 그리고 이것이 루프 기반 코드의 성능을 향상시키는 좋은 방법이 될 수 있지만, 당신은 여전히 이 기술을 분별 있게 사용해야 한다. 디스패치 큐는 오버 헤드가 매우 낮지만 쓰레드에서 각 루프 반복을 예약하는 데는 여전히 비용이 소요된다. 따라서 루프 코드가 비용을 보증할 수 있는 충분한 효과를 발휘하는지 확인해야 한다. 정확히 얼마나 많은 일을 해야 하는지는 성능 도구를 사용하여 측정해야 한다.

각 루프 반복에서 작업량을 늘리는 간단한 방법은 striding을 사용하는 것이다. striding을 사용하면 블록 코드를 다시 작성하여 원래 루프의 반복을 두 번 이상 수행한다. 그런 다음 `dispatch_apply`함수에 지정한 카운트 값을 비례적으로 감소시킨다. 목록 5-4는 [목록 5-3](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ThreadMigration/ThreadMigration.html#//apple_ref/doc/uid/TP40008091-CH105-SW5)에 표시된 루프 코드에 대한 striding을 구현하는 방법을 보여준다. 목록 5-4에서, 블록은 printf의 횟수를 보폭 값과 동일한 횟수로 호출되면, 이 경우 137이다. \(실제 stride 값은 코드에 의해 수행되는 작업을 기반으로 구성되어야 하는 것이다.\) 전체 반복 횟수를 stride 값으로 나눌 때 남은 시간이 있기 때문에 나머지 반복은 인라인으로 수행된다.

**목록 5-4** 루프를 위해 디스패치에 stride 추가

```objectivec
int stride = 137;
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 
dispatch_apply(count / stride, queue, ^(size_t idx){
    size_t j = idx * stride;
    size_t j_stop = j + stride;
    do {
       printf("%u\n", (unsigned int)j++);
    }while (j < j_stop);
});
 
size_t i;
for (i = count - (count % stride); i < count; i++)
   printf("%u\n", (unsigned int)i);
```

stride를 사용하는 것에는 확실한 성능 이점이 있다. 특히, stride는 stride에 비해 원래 루프 반복 횟수가 높을 때 이점을 제공한다. 더 적은 수의 블록을 동시에 발송하는 것은 블록 코드를 발송하는 것보다 더 많은 시간을 블록 코드를 실행하는 데 소비한다는 것을 의미한다. 그러나 다른 성능 메트릭과 마찬가지로, 코드에 가장 효율적인 값을 찾으려면 striding 값을 사용해야 할 수 있다.

### 쓰레드 조인 대체

쓰레드 조인은 하나 이상의 쓰레드를 생성한 다음 해당 쓰레드가 끝날 때까지 현재 쓰레드를 기다리게 한다. 쓰레드 조인을 구현하기 위해 부모는 결합 가능한 쓰레드로 자식 쓰레드를 생성한다. 부모가 더 이상 자식의 쓰레드에서 나온 결과 없이는 진전을 이룰 수 없을 때, 그것은 자식과 조인한다. 이 과정은 자식이 일을 끝내고 나갈 때까지 부모의 쓰레드를 차단하고, 그 때 부모는 자식으로부터 결과를 수집하고 자신의 일을 계속할 수 있다. 부모가 여러 개의 자식 쓰레드와 결합해야 한다면, 한 번에 하나씩 그렇게 한다.

디스패치 그룹은 쓰레드 조인과 유사하지만 몇 가지 추가적인 장점이 있는 의미를 제공한다. 쓰레드 조인과 마찬가지로 디스패치 그룹은 하나 이상의 하위 태스크 실행이 완료될 때까지 쓰레드를 차단하는 방법이다. 쓰레드 조인과 달리, 디스패치 그룹은 디스패치 큐를 이용하여 작업을 수행하기 때문에 매우 효율적이다.

조인 가능한 쓰레드에서 수행한 동일한 작업을 수행하기 위해 디스패치 그룹을 사용하려면 다음 작업을 수행한다:

1. [`dispatch_group_create`](https://developer.apple.com/documentation/dispatch/dispatchgroup/1452975-init) 함수를 사용하여 새 디스패치 그룹을 생성하라.
2. [`dispatch_group_async`](https://developer.apple.com/documentation/dispatch/1453084-dispatch_group_async) 또는 [`dispatch_group_async_f`](https://developer.apple.com/documentation/dispatch/1452864-dispatch_group_async_f) 함수를 사용하여 그룹에 태스크를 추가한다. 그룹에 제출하는 각 태스크는 일반적으로 결합 가능한 쓰레드에서 수행할 태스크를 나타낸다.
3. 현재 쓰레드가 더 이상 진행할 수 없는 경우 [`dispatch_group_wait`](https://developer.apple.com/documentation/dispatch/1452794-dispatch_group_wait) 함수를 호출하여 그룹에서 대기하라. 이 함수는 그룹의 모든 태스크가 실행을 마칠 때까지 현재 쓰레드를 차단한다.

오퍼레이션 객체를 사용하여 태스크를 구현하는 경우 종속서을 사용하여 쓰레드 조인을 구현할 수도 있다. 상위 쓰레드가 하나 이상의 태스크가 완료될 때까지 기다리게 하는 대신 상위 코드를 오퍼레이션 객체로 이동하라. 그런 다음 상위 오퍼레이션 객체와 조인 가능한 쓰레드에 의해 정상적으로 수행되는 태스크를 수행하도록 설정된 하위 오퍼레이션 객체 수 사이에 종속성을 설정한다. 다른 오퍼레이션 객체에 종속성을 가지면 모든 오퍼레이션이 완료될 때까지 상위 오퍼레이션 객체가 실행되지 않는다.

디스패치 그룹 사용 방법에 대한 예는, [Waiting on Groups of Queued Tasks](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW25)를 참조하라. 오퍼레이션 객체 간의 종속성 설정에 대한 자세한 내용은 [Configuring Interoperation Dependencies](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17)를 참조하라.

### 생산자-소비자 구현 변경

생산자-소비자 모델은 동적으로 생산되는 한정된 수의 리소스를 관리할 수 있게 해준다. 생산자가 새로운 리소스 \(또는 작업\)을 생성하는 동안 한 명 이상의 소비자는 그러한 리소스 \(또는 작업\)이 준비되기를 기다리고 있을 때 그것을 소비한다. 생산자-소비자 모델을 구현하기 위한 대표적인 메커니즘은 조건 또는 세마포어이다.

생산자 쓰레드는 조건을 사용하여 일반적으로 다음을 수행한다:

1. 조건과 연결된 뮤텍스를 락을 취한다. \(`pthread_mutex_lock` 사용\)
2. 소비할 리소스나 작업을 생산한다.
3. 소비할 것이 있다는 조건 변수에 신호한다. \(pthread\_second\_signal 사용\)
4. 뮤텍스를 락을 해제한다. \(`pthread_mutex_unlock`을 사용\)

해당 소비자 쓰레드는 다음의 순서와 같다:

1. 조건과 연결된 뮤텍스를 락을 취한다 \(pthread\_mutex\_lock 사용\).
2. 다음 작업을 수행하도록 `while` 루프를 설정하라:
   1. 정말로 작업이 완료되었는지 확인하라.
   2. 작업할 작업이 없거나 사용 가능한 리소스가 없는 경우, `pthread_second_wait`를 호출하여 해당 신호가 발생할 때까지 현재 쓰레드를 차단하라.
3. 생산자가 제공하는 작업 \(또는 자원\)을 얻어라.
4. 뮤텍스에 락을 해제하라. \(`pthread_mutex_unlock` 사용\).
5. 작업을 처리한다.

디스패치 큐를 통해 생산자 및 소비자 구현을 단일 호출로 단순화할 수 있다:

```objectivec
dispatch_async(queue, ^{
   // Process a work item.
});
```

생산자가 할 일이 있으면, 그 작업을 큐에 추가하고 큐가 항목을 처리하도록 하면 된다. 이전 코드에서 변경되는 유일하 부분은 큐 유형이다. 생산자가 생성한 태스크를 특정 순서로 수행해야 하는 경우, 시리얼 큐를 사용하라. 생산자가 생성한 태스크를 동시에 수행할 수 있는 경우, 콘커런트 큐에 추가하고 시스템에서 가능한 한 많은 태스크를 동시에 실행하도록 하라.

### 세마포어 코드 대체

현재 공유 리소스에 대한 접근을 제한하기 위해 세마포어를 사용하는 경우 대신 디스패치 세마포어를 사용하는 것을 고려해야 한다. 전통적인 세마포어는 항상 세마포어를 테스트하기 위해 커널로 내려갈 것을 요구한다. 이와는 대조적으로, 디스패치 세마포어는 사용자 공간에서 세마포어 상태를 빠르게 테스트하고 테스트가 실패하고 호출 스레드가 차단되어야 할 때만 커널에 트랩한다. 이러한 동작은 논란의 여지가 없는 경우의 전통적인 세마포어보다 훨씬 빠른 세마포어를 발송하는 결과를 낳는다. 그러나 다른 모든 측면에서, 디스패치 세마포어는 전통적인 세마포어와 같은 동작을 제공한다.

디스패치 세마포어를 사용하는 방법에 대한 예는 [Using Dispatch Semaphores to Regulate the Use of Finite Resources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24)를 참조하라.

### 런-루프 코드 대체

하나 이상의 쓰레드에서 수행되는 작업을 관리하기 위해 런 루프를 사용하는 경우 큐가 앞으로도 구현하고 유지하기가 훨씬 간단하다는 것을 알 수 있다. 사용자 정의 런 루프를 설정하는 것은 메인 쓰레드와 런 루프 자체를 설정하는 것을 포함한다. 런 루프 코드는 하나 이상의 런 루프 소스를 설정하고 해당 소스에 도착한 이벤트를 처리하기 위한 콜백을 작성하는 것으로 구성된다. 그 모든 작업 대신, 당신은 단순히 시리얼 큐를 생성하고 그 작업으로 태스크를 발송할 수 있다. 따라서 모든 쓰레드 및 런 루프 생성 코드를 한 줄의 코드로 교체할 수 있다.

```objectivec
dispatch_queue_t myNewRunLoop = dispatch_queue_create("com.apple.MyQueue", NULL);
```

큐는 큐에 추가된 태스크를 자동으로 실행하므로 큐 관리하는 데 추가 코드가 필요하지 않다. 쓰레드를 생성하거나 구성할 필요도 없고 런 루프 소스를 생성하거나 부착할 필요도 없다. 또한 큐에 태스크를 추가하기만 하면 큐에 대해 새로운 유형의 작업을 수행할 수 있다. 런 루프로 동일한 작업을 수행하려면 기존 런 루프 소스를 수정하거나 새 데이터를 처리할 새 런 루프 소스를 만들어야 한다.

런 루프의 한 가지 일반적인 구성은 네트워크 소켓에 비동기적으로 도착하는 데이터를 처리하는 것이다. 이러한 유형의 동작에 대해 런 루프를 구성하는 대신 원하는 큐에 디스패치 소스를 연결할 수 있다. 또한 디스패치 소스는 기존의 런 루프 소스보다 더 많은 데이터 처리 옵션을 제공한다. 타이머와 네트워크 포트 이벤트를 처리하는 것 외에도, 파일들을 읽고 쓰고, 파일 시스템 객체를 모니터하고, 프로세스를 모니터하고, 신호를 감시 하는 데 디스패치 소스를 사용할 수 있다. 사용자 정의 디스패치 소스를 정의하고 비동기적으로 코드의 다른 부분에서 트리거 할 수도 있다. 디스패치 소스 설정에 대한 자세한 내용은 [Dispatch Sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1)를 참조하라.

### POSIX 쓰레드와의 호환성

Grand Central Dispatch는 제공하는 태스크와 해당 태스크가 실행되는 쓰레드 간의 관계를 관리하기 때문에 일반적으로 태스크 코드에서 POSIX 쓰레드 루틴을 호출하는 것을 피해야 한다. 만약 당신이 어떤 이유로 그들을 부를 필요가 있다면, 당신은 어떤 루틴을 부르는지에 대해 매우 조심해야 한다. 이 절에서는 어떤 루틴을 호출하기에 안전하며 대기 중인 태스크에서 호출하기에 안전하지 않은지 알려준다. 이 목록은 완전하지는 않지만 당신에게 무엇이 호출하기에 안전한지 그리고 그렇지 않은지를 알려줄 것이다.

일반적으로 애플리케이션은 생성하지 않은 객체나 데이터 구조를 삭제하거나 변경하지 않아야 한다. 따라서 디스패치 큐를 사용하여 실행되는 블록 객체는 다음 함수를 호출해서는 안 된다:

* `pthread_detach`
* `pthread_cancel`
* `pthread_join`
* `pthread_kill`
* `pthread_exit`

태스크가 실행되는 동안 쓰레드의 상태를 수정하는 것은 괜찮지만 태스크가 반환되기 전에 쓰레드를 원래 상태로 되돌려야 한다. 따라서 쓰레드를 원래 상태로 되돌리는 한 다음과 같은 함수를 호출해도 안전하다:

* `pthread_setcancelstate`
* `pthread_setcanceltype`
* `pthread_setschedparam`
* `pthread_sigmask`
* `pthread_setspecific`

주어진 블록을 실행하는 데 사용되는 메인 쓰레드는 호출에서 호출로 변경될 수 있다. 따라서 애플리케이션은 블록 호출 간에 예측 가능한 결과를 반환하는 다음 함수에 의존해서는 안 된다:

* `pthread_self`
* `pthread_getschedparam`
* `pthread_get_stacksize_np`
* `pthread_get_stackaddr_np`
* `pthread_mach_thread_np`
* `pthread_from_mach_thread_np`
* `pthread_getspecific`

> **중요:** 블록은 해당 블록 안에 있는 모든 언어 수준의 예외를 포착하고 억제해야 한다. 블록을 실행하는 동안 발생하는 다른 오류는 블록에서 처리하거나 애플리케이션의 다른 부분에 통보하는 데 사용되어야 한다.

POSIX 쓰레드 및 이 절에 언급된 함수에 대한 자세한 내용은 [`pthread`](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread) 메뉴얼 페이지를 참조하라.

