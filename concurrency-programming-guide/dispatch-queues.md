# Dispatch Queues

GCD\(Grand Central Dispatch\) 디스패치 큐는 작업을 수행하기 위한 강력한 도구이다. 디스패치 큐를 통해 발신자와 관련하여 비동기 또는 동기식으로 임의의 코드 블록을 실행할 수 있다. 디스패치 큐를 사용하여 별도의 쓰레드에서 수행하는 데 사용한 거의 모든 태스크를 수행할 수 있다. 디스패치 큐의 장점은 해당 쓰레드 코드보다 사용이 간편하고 태스크를 실행하는 데 훨씬 효율적이라는 것이다.

이 장에서는 애플리케이션에서 일반 태스크를 실행하는 데 사용하는 방법에 대한 정보와 함께 디스패치 큐에 대한 소개를 제공한다. 기존의 쓰레드 코드를 디스패치 큐로 바꾸려면 Migrating Away from Threads을 통해 쓰레드 코드 사용 방법에 대한 몇가지 추가적인 팁을 참조하라.

## About Dispatch Queues

디스패치 큐는 애플리케이션에서 작업을 비동기적으로 동시에 수행하는 쉬운 방법이다. 태스크는 단순히 당신의 애플리케이션이 수행해야 하는 일부 작업이다. 예를 들어, 어떤 계산을 수행하거나, 데이터 구조를 생성 또는 수정하거나, 파일에서 읽은 일부 데이터를 처리하거나, 또는 여러가지 작업을 처리하는 태스크를 정의할 수 있다. 함수 또는 블록 객체 내부에 해당 코드를 배치하고 디스패치 큐에 추가하여 태스크를 정의한다.

디스패치 큐는 제출하는 태스크를 관리하는 object-like 구조이다. 모든 디스패치 큐는 선입선출 데이터 구조이다. 따라서 큐에 추가하는 태스크는 항상 추가된 순서대로 시작된다. GCD는 자동으로 일부 디스패치 큐를 제공하지만 특정 목적을 위해 생성할 수 있는 다른 디스패치 큐도 제공한다. Table 3-1에는 애플리케이션에 사용할 수 있는 디스패치 큐의 유형 및 사용 방법이 나와 있다.

**Table 3-1** Types of dispatch queues

| Type | Description |
| :--- | :--- |
| Serial | 시리얼 큐\(private 디스패치 큐라고도 함\)는 큐에 추가된 순서대로 한 번에 하나의 태스크를 실행한다. 현재 실행 중인 태스크는 디스패치 큐에 의해 관리되는 별개의 쓰레드\(태스크 마다 다를 수 있음\)에서 실행된다. 시리얼 큐는 종종 특정 리소스에 대한 액세스를 동기화하는 데 사용 된다. 필요한 만큼 많은 시리얼 큐를 생성할 수 있으며, 각 큐는 다른 모든 큐와 동시에 작동한다. 즉, 4개의 시리얼 큐를 생성하면 각 큐는 한 번에 하나의 작업만 실행하지만 각 큐에서 최대 4개의 작업이 동시에 실행될 수 있다. 시리얼 큐를 생성하는 방법에 대한 자세한 내용은 Creating Serial Dispatch Queues를 참조하라. |
| Concurrent | 컨커런트 큐\(글로벌 디스패치 큐라고도 함\)는 하나 이상의 태스크를 동시에 실행하지만 태스크는 대기열에 추가된 순서대로 여전히 시작된다. 현재 실행 중인 태스크는 디스패치 큐에 의해 관리되는 별개의 쓰레드에서 실행된다. 특정 지점에서 실행되는 태스크의 정확한 수는 가변적이며 시스템 조건에 따라 달라진다. iOS 5 이상에서는 `DISPATCH_QUEUE_CONCURRENT` 를 큐 유형으로 지정하여 컨커런트 큐를 직접 생성할 수 있다. 또한 애플리케이션이 사용할 미리 정의된 글로벌 컨커런트 큐 4개가 있다. 글로벌 컨커런트 큐를 가져오는 방법에 대한 자세한 내용은 Getting the Global Concurrent Dispatch Queues를 참조하라. |
| Main dispatch queue | 메인 디스패치 큐는 메인 쓰레드 태스크를 실행하고 있는 시리얼 큐를 전역으로 사용 가능합니다. 이 큐는 애플리케이션의 런 루프\(있는 경우\)와 함께 작동하여 대기 중인 태스크의 실행을 런 루프에 연결된 다른 이벤트 소스의 실행과 상호 작용한다. 애플리케이션의 메인 쓰레드에서 실행된 큐는 종종 애플리케이션에 대한 주요 동기점으로 사용된다. 메인 디스패치 큐를 생성하지 않아도 애플리케이션이 그것을 적절하게 제거하는지 확인할 필요가 있다. 이 큐가 어떻게 관리되는지에 대한 자세한 내용은 Performing Tasks on the Main Thread를 참조하라. |

애플리케이션에 동시성을 추가하는 것에 관해 디스패치 큐 쓰레드에 대한 여럿의 이점을 제공한다. work-queue 프로그래밍 모델의 가장 직접적인 장점은 간단함이다. 당신은 수행을 원하는 쓰레드의 생성과 쓰레드를 관리하는 작업에 대한 코드를 작성해야한다. 디스패치 큐는 실제로 쓰레드 생성과 관리 수행에 걱정 없이 작업에 집중하게 해준다. 대신, 그 시스템이 모든 쓰레드의 생성 및 관리 전반을 담당한다. 시스템의 장점은 단일 애플리케이션보다 쓰레드를 더 효율적으로 관리할 수 있다. 그 시스템은 사용 가능한 자원과 현재 시스템 조건에 기초를 둔 쓰레드의 수를 동적으로 확장할 수 있다. 게다가, 시스템은 보통 직접 쓰레드를 만들었을 때보다 더 빨리 당신의 태스크를 실행할 수 있다.

디스패치 큐를 위해 코드를 재작성하는 것이 어려울것이라고 생각 할 수 있지만, 쓰레드에 코드를 작성하는 것보다 디스패치 큐의 코드를 작성하는 것이 더 쉬운 경우가 많다. 코드를 작성하는 데 있어 핵심은 비동기적으로 실행할 수 있는 태스크를 설계하는 것이다. \(이것은 쓰레드와 디스패치 큐 모두 해당한다.\) 그러나 디스패치 큐가 예측 가능성에 있어 유리하다. 동일한 공유 리소스에 액세스하지만 서로 다른 쓰레드에서 실행되는 두 태스크가 있는 경우 두 쓰레드는 먼저 리소스를 수정할 수 있으며 두 태스크가 동시에 해당 리소스를 수정하지 않도록 락을 사용해야 한다. 디스패치 큐를 사용하면 두 태스크를 시리얼 디스패치 큐에 추가하여 지정된 시간에 한 태스크만 리소스를 수정하도록 할 수 있다. 이 유형의 큐 기반 동기화는 락 보다 더 효율적이다. 락은 항상 경쟁 비경쟁상태 모두 값비싼 커널 트랩이 필요하기 때문이다. 디스패치 큐는 주로 애플리케이션 프로세스 공간에서 작동하며 절대적으로 필요한 경우에만 커널로 호출한다.

시리얼 큐에서 실행되는 두 개의 태스크가 동시에 실행되지 않는다는 점을 지적하는 것이 옳더라도 두 개의 쓰레드가 동시에 잠기면 쓰레드가 제공하는 동시성이 상실되거나 현저히 감소한다는 점을 기억해야 한다. 더 중요한 것은, 쓰레드 모델은 커널과 사용자-공간 메모리를 모두 차지하는 두 개의 쓰레드를 생성해야 한다는 것이다. 디스패치 큐는 쓰레드에 대해 동일한 메모리 패널티를 지불하지 않으며, 그들이 사용하는 쓰레드는 사용량이 많고 차단되지 않는다.

디스패치 큐에 대해 기억해야 할 다른 주요 사항에는 다음이 포함된다.

* 디스패치 큐는 다른 디스패치 큐와 동시에 태스크를 수행한다. 일련의 태스크는 단일 디스패치 큐에 있는 태스크로 제한된다.
* 시스템은 한 번에 실행하는 총 태스크 수를 결정한다. 따라서 100개의 다른 큐에서 100개의 태스크를 가진 애플리케이션은 모든 태스크를 동시에 실행하지 못할 수 있다. \(100개 이상의 유효 코어를 가지고 있지 않는 한\)
* 시스템은 시작할 새 태스크를 선택할 때 큐 우선 순위를 고려한다. 시리얼 큐의 우선 순위를 설정하는 방법에 대한 자세한 내용은 Providing a Clean Up Function For a Queue를 참조하라.
* 큐의 태스크는 큐에 추가될 때 실행할 준비가 되어 있어야 한다. \(이전에 Cocoa 오퍼레이션 객체를 사용한 적이 있는 경우 이 동작은 모델 오퍼레이션 사용과 다르다는 점에 유의하라.\)
* Private 디스패치 큐는 참조 카운트 객체이다. 코드로 큐를 유지하는 것 외에도 디스패치 소스가 큐에 부착될 수 있고 리테인 카운트를 증가시킬 수 있다는 점에 유의하라. 따라서 모든 디스패치 소스가 취소되고 모든 릴리스 호출로 리테인 호출이 균형을 이루도록 해야 한다. 큐 리테인 및 릴리스에 대한 자세한 내용은 Memory Management for Dispatch Queues를 참조하라. 디스패치 소스에 대한 자세한 내용은 About Dispatch Sources를 참조하라.

디스패치 큐를 조작하는 데 사용하는 인터페이스에 대한 자세한 내용은 GCD\(Grand Central Dispatch\) 를 참조하라.

## Queue-Related Technologies

Grand Central Dispatch는 디스패치 큐 외에도 큐를 사용하여 코드를 관리하는 데 도움이 되는 몇 가지 기술을 제공한다. Table 3-2는 이러한 기술들을 나열하고 당신이 그것에 대해 더 많은 정보를 찾을 수 있는 곳에 대한 링크를 제공한다.

**Table 3-2** Technologies that use dispatch queues

| **Technology** | **Description** |
| :--- | :--- |
| Dispatch groups | 디스패치 그룹은 블록 객체 셋을 모니터링하여 완료하는 방법이다. \(필요에 따라 블록을 동기식 또는 비동기식으로 모니터링할 수 있다.\) 그룹은 다른 태스크의 완료에 따라 달라지는 코드에 대한 유용한 동기화 메커니즘을 제공한다. 그룹 사용에 대한 자세한 정보는 Waiting on Groups of Queued Tasks를 참조하라. |
|  |  |
|  |  |

